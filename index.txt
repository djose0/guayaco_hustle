<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Guayaco Hustle: Final Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Arial Black', sans-serif; }
        
        #ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        .screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; z-index: 20; color: white; text-align: center; }
        .hidden { display: none !important; }

        /* INTRO TEXT */
        #intro-text {
            position: absolute; top: 30%; width: 100%; text-align: center;
            font-size: 60px; color: #ff3333; text-shadow: 4px 4px 0 #000;
            opacity: 0; transition: opacity 0.2s; pointer-events: none; z-index: 15;
        }
        .pop-in { opacity: 1 !important; transform: scale(1.2); animation: shake 0.3s; }
        
        @keyframes shake {
            0%, 100% { transform: scale(1.2) rotate(0deg); }
            25% { transform: scale(1.3) rotate(-5deg); }
            75% { transform: scale(1.3) rotate(5deg); }
        }

        h1 { color: #FFC107; font-size: 40px; margin: 0; text-shadow: 3px 3px 0 #002244; transform: skew(-5deg); text-transform: uppercase; letter-spacing: 2px; }
        p { color: #ccc; font-size: 14px; margin-bottom: 20px; font-weight: normal; }
        
        .btn {
            background: #0033A0; border: 2px solid #4facfe; padding: 15px 40px; margin: 10px;
            color: white; font-size: 18px; font-weight: bold; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 6px #001133; transform: skew(-5deg); min-width: 200px; transition: transform 0.1s;
        }
        .btn:active { transform: skew(-5deg) translateY(4px); box-shadow: 0 2px #001133; }
        .btn-shop { background: #D32F2F; border-color: #ff6666; box-shadow: 0 6px #550000; }
        .btn-shop:active { box-shadow: 0 2px #550000; }

        #hud { padding: 20px; display: flex; justify-content: space-between; font-size: 24px; color: #FFC107; text-shadow: 2px 2px 0 #000; font-weight: bold; }
        
        /* TIENDA */
        #shop-container { width: 90%; max-height: 50vh; overflow-y: auto; background: rgba(255,255,255,0.05); padding: 10px; border-radius: 8px; margin-bottom: 15px; }
        #shop-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .shop-item { background: #2a2a2a; padding: 10px; border: 2px solid #444; border-radius: 5px; cursor: pointer; display: flex; flex-direction: column; align-items: center; }
        .shop-item.owned { border-color: #4CAF50; background: #1b331b; }
        .shop-item.equipped { border-color: #FFC107; box-shadow: 0 0 15px rgba(255, 193, 7, 0.4); }
        .preview-box { font-size: 30px; margin-bottom: 5px; }

        #popup-msg {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            font-size: 40px; color: #4CAF50; text-shadow: 0 0 10px #000;
            opacity: 0; pointer-events: none; font-weight: 900; transition: opacity 0.3s;
        }

        /* Stats en men√∫ principal */
        .menu-stats {
            display: flex; gap: 40px; margin: 15px 0; margin-bottom: 25px;
        }
        .stat-box {
            background: rgba(0, 51, 160, 0.35);
            border: 1px solid rgba(79, 172, 254, 0.4);
            border-radius: 8px;
            padding: 10px 22px;
            min-width: 120px;
        }
        .stat-label {
            font-size: 11px; color: #7ec8e3; text-transform: uppercase;
            letter-spacing: 1.5px; margin-bottom: 4px; font-weight: bold;
        }
        .stat-value {
            font-size: 22px; color: #FFC107; font-weight: 900;
            text-shadow: 2px 2px 0 #001133;
        }
        
        /* Error Loader */
        #loader { z-index: 100; background: #111; }
        #error-msg { color: red; margin-top: 20px; font-family: monospace; display: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" onerror="document.getElementById('error-msg').style.display='block'; document.getElementById('error-msg').innerText='Error: No internet connection for Three.js'"></script>
</head>
<body>

    <div id="loader" class="screen">
        <h1 style="color:#4facfe">CARGANDO...</h1>
        <div id="error-msg"></div>
    </div>

    <div id="intro-text">¬°CHORO!</div>

    <div id="ui">
        <div id="popup-msg">+$50</div>
        
        <div id="hud" class="hidden">
            <span id="score-lbl">0m</span>
            <span id="cash-lbl">$0</span>
        </div>

        <div id="main-menu" class="screen hidden">
            <h1>GUAYACO<br>HUSTLE</h1>
            <p>BAH√çA EDITION</p>
            <!-- Stats: plata total y record -->
            <div class="menu-stats">
                <div class="stat-box">
                    <div class="stat-label">üí∞ Billetera</div>
                    <div class="stat-value" id="menu-cash">$0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">üèÜ Mejor Marca</div>
                    <div class="stat-value" id="menu-record">0m</div>
                </div>
            </div>
            <p style="font-size:11px; color:#aaa">Arriba: Saltar | Abajo: Agacharse</p>
            <button class="btn" onclick="triggerIntroSequence()">JUGAR</button>
            <button class="btn btn-shop" onclick="openShop()">TIENDA</button>
        </div>

        <div id="shop-screen" class="screen hidden">
            <h1>LA CACHINA</h1>
            <p>Billetera: <span id="shop-cash" style="color:#FFC107">$0</span></p>
            <div id="shop-container"><div id="shop-grid"></div></div>
            <button class="btn" style="background:#444; border-color:#666" onclick="closeShop()">VOLVER</button>
        </div>

        <div id="game-over" class="screen hidden">
            <h2 style="font-size: 32px; color:#ff4444; margin:10px">¬°TE LLEVARON!</h2>
            <p>Recorriste: <span id="final-score">0m</span></p>
            <p>Plata: <span id="final-cash" style="color:#FFC107">$0</span></p>
            <div>
                <button class="btn" onclick="triggerIntroSequence()">REINTENTAR</button>
                <button class="btn btn-shop" onclick="goToMenu()">MEN√ö</button>
            </div>
        </div>
    </div>

<script>
    // --- COLORES ATMOSF√âRICOS (ATARDECER GUAYAQUIL) ---
    const COLORS = {
        sky: 0xFF8C42,
        skyGround: 0x5B7C99,
        fog: 0xE6A57E,
        road: 0x2a2a2a,
        taxi: 0xFFD700,
        bus: 0x1E5A8E,
        skin: 0xD4A07D,
        shirt: 0x224488,
        pants: 0x222222
    };

    const SKINS = [
        { id: 'brayan', name: 'El Brayan', price: 0, icon: 'üß¢', desc: 'Camiseta Emelec' },
        { id: 'uartes', name: 'UArtes', price: 5000, icon: 'üé®', desc: 'Negro + Tote Bag' },
        { id: 'ani', name: 'Ani√±ado', price: 10000, icon: 'üëï', desc: 'Polo Rosada' },
        { id: 'bsc', name: 'El √çdolo', price: 25000, icon: 'üü°', desc: 'Camiseta BSC' },
        { id: 'alien', name: 'Alien', price: 50000, icon: 'üëΩ', desc: 'Area 51' }
    ];

    // Variables Globales
    let scene, camera, renderer, clock;
    let playerGroup, playerLimbs = {}; 
    let civilianGroup, cops = [];
    let obstacles = [], scenery = [];
    let particles = [];
    let audioCtx;

    // FIX 1: Array para l√≠neas amarillas reciclables
    let roadLines = [];

    // Estado
    let gameState = 'LOADING'; 
    let lanes = [-3, 0, 3];
    let currentLane = 1;
    let speed = 10;
    let score = 0;
    let cash = 0;
    
    // Persistencia
    let totalCash = parseInt(localStorage.getItem('gh_total_cash')) || 0;
    let ownedSkins = JSON.parse(localStorage.getItem('gh_owned_skins')) || ['brayan'];
    let currentSkinId = localStorage.getItem('gh_current_skin') || 'brayan';
    // FIX 3: Record persistente
    let bestScore = parseInt(localStorage.getItem('gh_best_score')) || 0;

    // F√≠sicas
    let playerY = 0, verticalVel = 0;
    let isJumping = false, isDucking = false, duckTimer = 0;
    const GRAVITY = -65, JUMP_FORCE = 16;

    // Timers
    let masterSpawnTimer = 0;
    let sceneryTimer = 0;
    let introTimer = 0;
    let arrestTimer = 0;
    let hasHitPlayed = false;
    let hasWhistlePlayed = false;
    
    // Camera shake
    let cameraShake = 0;
    let cameraShakeIntensity = 0;

    window.onload = function() {
        if (typeof THREE === 'undefined') return;
        try {
            init3D();
            renderShop();
            updateMenuStats(); // FIX 3: Mostrar stats en men√∫ al cargar
            setTimeout(() => {
                document.getElementById('loader').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
                gameState = 'MENU';
            }, 800);
        } catch(e) { console.error(e); }
    };

    // FIX 3: Funci√≥n para actualizar stats en men√∫
    function updateMenuStats() {
        document.getElementById('menu-cash').innerText = '$' + totalCash;
        document.getElementById('menu-record').innerText = bestScore + 'm';
    }

    function init3D() {
        scene = new THREE.Scene();
        
        // === ILUMINACI√ìN AVANZADA ===
        const hemiLight = new THREE.HemisphereLight(COLORS.sky, COLORS.skyGround, 0.6);
        scene.add(hemiLight);
        
        const sunLight = new THREE.DirectionalLight(0xFFAA66, 1.2);
        sunLight.position.set(20, 35, 15);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 200;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        scene.add(sunLight);
        
        const ambientLight = new THREE.AmbientLight(0xFFE4CC, 0.4);
        scene.add(ambientLight);
        
        // === NIEBLA VOLUM√âTRICA ===
        scene.fog = new THREE.FogExp2(COLORS.fog, 0.012);
        scene.background = new THREE.Color(COLORS.sky);

        camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 300);
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, -5);

        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        document.body.appendChild(renderer.domElement);

        // === SUELO ===
        const roadGeo = new THREE.PlaneGeometry(12, 1000);
        const roadMat = new THREE.MeshStandardMaterial({
            color: COLORS.road,
            roughness: 0.9,
            metalness: 0.1
        });
        const road = new THREE.Mesh(roadGeo, roadMat);
        road.rotation.x = -Math.PI/2;
        road.position.z = -400;
        road.receiveShadow = true;
        scene.add(road);
        
        // FIX 1: L√≠neas amarillas reciclables (se mueven con speed)
        // Espaciado de 10 unidades, creo suficientes para cubrir la pantalla visible
        const lineMat = new THREE.MeshStandardMaterial({color: 0xFFDD00, emissive: 0xFFDD00, emissiveIntensity: 0.2});
        const lineGeo = new THREE.BoxGeometry(0.3, 0.05, 4);
        for(let i = 0; i < 20; i++) {
            const line = new THREE.Mesh(lineGeo, lineMat);
            // Las posiciono entre z=-190 y z=10 con espaciado de 10
            line.position.set(0, 0.03, -190 + i * 10);
            scene.add(line);
            roadLines.push(line);
        }

        // === VEREDAS ===
        const sidewalkMat = new THREE.MeshStandardMaterial({color: 0x555555, roughness: 0.8});
        const swL = new THREE.Mesh(new THREE.BoxGeometry(5, 0.5, 1000), sidewalkMat);
        swL.position.set(-8.5, -0.2, -400);
        swL.receiveShadow = true;
        scene.add(swL);
        
        const swR = new THREE.Mesh(new THREE.BoxGeometry(5, 0.5, 1000), sidewalkMat);
        swR.position.set(8.5, -0.2, -400);
        swR.receiveShadow = true;
        scene.add(swR);
        
        // Postes de luz en veredas
        for(let z = -400; z < 0; z += 40) {
            [-8.5, 8.5].forEach(x => {
                const poleGroup = new THREE.Group();
                
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.12, 6, 8),
                    new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.4, metalness: 0.6})
                );
                pole.position.y = 3;
                pole.castShadow = true;
                poleGroup.add(pole);
                
                const light = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xFFCC88,
                        emissive: 0xFFAA44,
                        emissiveIntensity: 2
                    })
                );
                light.position.y = 6;
                poleGroup.add(light);
                
                const pointLight = new THREE.PointLight(0xFFAA44, 0.5, 15);
                pointLight.position.y = 6;
                poleGroup.add(pointLight);
                
                poleGroup.position.set(x, 0, z);
                scene.add(poleGroup);
            });
        }

        buildCitySkyline();
        createPlayer();
        setupInputs();
        
        clock = new THREE.Clock();
        animate();
    }

    function buildCitySkyline() {
        const cityGroup = new THREE.Group();
        
        for (let i = -12; i < 12; i++) {
            const h = 25 + Math.random() * 40; 
            const w = 5 + Math.random() * 5;
            
            const buildingMat = new THREE.MeshStandardMaterial({
                color: 0x4A5568,
                roughness: 0.7,
                metalness: 0.2
            });
            const building = new THREE.Mesh(new THREE.BoxGeometry(w, h, 10), buildingMat);
            building.position.set(i * 12, h/2 - 5, -160);
            building.castShadow = true;
            cityGroup.add(building);
            
            for(let y = 2; y < h - 2; y += 4) {
                for(let x = -w/2 + 1; x < w/2; x += 1.5) {
                    if(Math.random() > 0.4) {
                        const isLit = Math.random() > 0.3;
                        const window = new THREE.Mesh(
                            new THREE.BoxGeometry(0.8, 2, 0.2),
                            new THREE.MeshStandardMaterial({
                                color: isLit ? 0xFFFFAA : 0x222222,
                                emissive: isLit ? 0xFFDD88 : 0x000000,
                                emissiveIntensity: isLit ? 1.5 : 0
                            })
                        );
                        window.position.set(x, y - h/2, 5.1);
                        building.add(window);
                    }
                }
            }
        }
        scene.add(cityGroup);
    }

    // FIX 2: Crear edificio lateral para spawn din√°mico
    function createSideBuilding() {
        const group = new THREE.Group();
        const h = 4 + Math.random() * 12;
        const w = 3 + Math.random() * 4;
        const d = 4 + Math.random() * 5;

        // Paleta de colores Bah√≠a Guayaquil
        const colorPalette = [
            0x8B6F47, // terracotta / adobe
            0xC4956A, // arena c√°lida
            0xA0826D, // arcilla
            0x6B8E6B, // verde urbano apagado
            0x7A8FA6, // azul gris√°ceo
            0xB8976A, // ocre
            0xC97F5B, // naranja terracotta
            0x5C6B7A, // techo gris azulado
            0xD4A574, // beige warm
            0x9E7B5A  // caf√© medio
        ];
        const baseColor = colorPalette[Math.floor(Math.random() * colorPalette.length)];

        const buildingMat = new THREE.MeshStandardMaterial({
            color: baseColor,
            roughness: 0.75,
            metalness: 0.1
        });

        const body = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), buildingMat);
        body.position.y = h / 2;
        body.castShadow = true;
        body.receiveShadow = true;
        group.add(body);

        // Ventanas iluminadas
        const windowsPerRow = Math.floor(w / 1.2);
        const windowRows = Math.floor(h / 2);
        for(let row = 0; row < windowRows; row++) {
            for(let col = 0; col < windowsPerRow; col++) {
                if(Math.random() > 0.35) {
                    const isLit = Math.random() > 0.3;
                    const win = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 1.0, 0.05),
                        new THREE.MeshStandardMaterial({
                            color: isLit ? 0xFFFFAA : 0x222222,
                            emissive: isLit ? 0xFFDD88 : 0x000000,
                            emissiveIntensity: isLit ? 1.8 : 0
                        })
                    );
                    const xOff = -w/2 + 0.8 + col * (w / windowsPerRow);
                    const yOff = 1.2 + row * 2 - h/2;
                    win.position.set(xOff, yOff, d/2 + 0.03);
                    body.add(win);
                }
            }
        }

        // Techo plano con detalle (tanque de agua ‚Äî muy Guayaquil)
        if(Math.random() > 0.45) {
            const tankW = 0.8 + Math.random() * 0.6;
            const tankH = 0.6 + Math.random() * 0.5;
            const tank = new THREE.Mesh(
                new THREE.BoxGeometry(tankW, tankH, tankW),
                new THREE.MeshStandardMaterial({color: 0x888888, roughness: 0.5, metalness: 0.3})
            );
            tank.position.set(
                (Math.random() - 0.5) * (w * 0.5),
                h + tankH/2,
                (Math.random() - 0.5) * (d * 0.4)
            );
            tank.castShadow = true;
            group.add(tank);
        }

        // Balc√≥n en algunos edificios
        if(Math.random() > 0.5 && h > 5) {
            const balconyRow = 1 + Math.floor(Math.random() * (windowRows - 1));
            const balcony = new THREE.Mesh(
                new THREE.BoxGeometry(w * 0.7, 0.12, 1.2),
                new THREE.MeshStandardMaterial({color: 0xCCBBAA, roughness: 0.7})
            );
            balcony.position.set(0, 1.8 + balconyRow * 2 - h/2, d/2 + 0.5);
            balcony.castShadow = true;
            body.add(balcony);

            // Pasamanos del balc√≥n
            const railMat = new THREE.MeshStandardMaterial({color: 0x888888, metalness: 0.5, roughness: 0.4});
            const rail = new THREE.Mesh(
                new THREE.BoxGeometry(w * 0.7, 0.6, 0.04),
                railMat
            );
            rail.position.set(0, 0.3, 0.58);
            balcony.add(rail);
        }

        return { group, h, w, d };
    }

    // === CREADOR DE PERSONAJE ===
    function createPlayer() {
        if (playerGroup) scene.remove(playerGroup);
        playerGroup = new THREE.Group();
        playerLimbs = {};

        const skinColor = currentSkinId === 'alien' ? 0x33ff33 : COLORS.skin;
        const skinMat = new THREE.MeshStandardMaterial({
            color: skinColor,
            roughness: 0.6,
            metalness: 0.1
        });
        
        let shirtC = 0x888888, pantsC = 0x222222;
        let hasCap=false, hasGlasses=false, hasSweater=false, hasBag=false, isAlien=false;

        if (currentSkinId === 'brayan') { shirtC = 0x0044CC; pantsC = 0x333333; hasCap = true; } 
        else if (currentSkinId === 'uartes') { shirtC = 0x111111; pantsC = 0x111111; hasGlasses = true; hasBag = true; } 
        else if (currentSkinId === 'ani') { shirtC = 0xFF99CC; pantsC = 0xCCCCAA; hasSweater = true; } 
        else if (currentSkinId === 'bsc') { shirtC = 0xFFFF00; pantsC = 0x111111; } 
        else if (currentSkinId === 'alien') { isAlien = true; }

        const torsoMat = new THREE.MeshStandardMaterial({
            color: isAlien ? 0x33ff33 : shirtC,
            roughness: 0.7,
            metalness: 0.1
        });
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.9, 0.4), torsoMat);
        torso.position.y = 1.35;
        torso.castShadow = true;
        torso.receiveShadow = true;
        playerGroup.add(torso);

        if (hasSweater) {
            const sw = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.3, 0.5),
                new THREE.MeshStandardMaterial({color: 0x88CCFF, roughness: 0.5})
            );
            sw.position.set(0, 0.35, 0);
            torso.add(sw);
        }
        if (hasBag) {
            const bag = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.6, 0.5),
                new THREE.MeshStandardMaterial({color: 0xDDDDDD, roughness: 0.4})
            );
            bag.position.set(0.4, -0.1, 0);
            bag.castShadow = true;
            torso.add(bag);
        }

        const headSize = isAlien ? 0.9 : 0.6;
        const head = new THREE.Mesh(new THREE.BoxGeometry(headSize, headSize, headSize), skinMat);
        head.position.y = isAlien ? 0.8 : 0.85;
        head.castShadow = true;
        torso.add(head);

        if (hasCap) {
            const cap = new THREE.Mesh(
                new THREE.BoxGeometry(0.62, 0.2, 0.7),
                new THREE.MeshStandardMaterial({color: 0xFF0000, roughness: 0.6})
            );
            cap.position.set(0, 0.2, 0.1);
            cap.castShadow = true;
            head.add(cap);
        }
        if (hasGlasses) {
            const gl = new THREE.Mesh(
                new THREE.BoxGeometry(0.65, 0.15, 0.1),
                new THREE.MeshStandardMaterial({
                    color: 0x000000,
                    roughness: 0.1,
                    metalness: 0.8,
                    transparent: true,
                    opacity: 0.7
                })
            );
            gl.position.set(0, 0, -0.3);
            head.add(gl);
        }
        if (isAlien) { 
            const eyeGeo = new THREE.BoxGeometry(0.2, 0.3, 0.1);
            const eyeMat = new THREE.MeshStandardMaterial({
                color: 0x000000,
                emissive: 0x000000
            });
            const el = new THREE.Mesh(eyeGeo, eyeMat);
            el.position.set(-0.25, 0, -0.45);
            head.add(el);
            const er = new THREE.Mesh(eyeGeo, eyeMat);
            er.position.set(0.25, 0, -0.45);
            head.add(er);
        }

        function createLimb(w, h, d, color, x, y, z) {
            const g = new THREE.BoxGeometry(w, h, d);
            g.translate(0, -h/2, 0);
            const m = new THREE.Mesh(g, new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.7,
                metalness: 0.1
            }));
            m.position.set(x, y, z);
            m.castShadow = true;
            return m;
        }

        const lColor = isAlien ? 0x33ff33 : pantsC;
        const armColor = isAlien ? 0x33ff33 : skinColor;

        const armL = createLimb(0.25, 0.8, 0.25, armColor, -0.5, 0.4, 0);
        const armR = createLimb(0.25, 0.8, 0.25, armColor, 0.5, 0.4, 0);
        const legL = createLimb(0.3, 0.9, 0.3, lColor, -0.2, -0.45, 0);
        const legR = createLimb(0.3, 0.9, 0.3, lColor, 0.2, -0.45, 0);

        torso.add(armL); torso.add(armR); torso.add(legL); torso.add(legR);
        playerLimbs = { armL, armR, legL, legR };
        scene.add(playerGroup);
    }

    function createCop(side) {
        const group = new THREE.Group();
        const blueMat = new THREE.MeshStandardMaterial({
            color: 0x001133,
            roughness: 0.6,
            metalness: 0.2
        });
        
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.9, 0.45), blueMat);
        torso.position.y = 1.35;
        torso.castShadow = true;
        group.add(torso);
        
        const head = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.6, 0.6),
            new THREE.MeshStandardMaterial({color: 0xCCAA88, roughness: 0.7})
        );
        head.position.y = 0.85;
        head.castShadow = true;
        torso.add(head);
        
        const cap = new THREE.Mesh(new THREE.BoxGeometry(0.62, 0.25, 0.65), blueMat);
        cap.position.set(0, 0.3, 0);
        cap.castShadow = true;
        head.add(cap);
        
        const armRGeo = new THREE.BoxGeometry(0.25, 0.8, 0.25);
        armRGeo.translate(0, -0.4, 0);
        const armR = new THREE.Mesh(armRGeo, blueMat);
        armR.position.set(0.5, 0.4, 0);
        armR.castShadow = true;
        torso.add(armR);
        
        const stick = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8),
            new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.3, metalness: 0.7})
        );
        stick.position.set(0, -0.7, 0.2);
        stick.rotation.x = Math.PI/2;
        stick.castShadow = true;
        armR.add(stick);

        const armLGeo = new THREE.BoxGeometry(0.25, 0.8, 0.25);
        armLGeo.translate(0, -0.4, 0);
        const armL = new THREE.Mesh(armLGeo, blueMat);
        armL.position.set(-0.5, 0.4, 0);
        armL.castShadow = true;
        torso.add(armL);

        const legL = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), blueMat);
        legL.position.set(-0.2, -0.9, 0);
        legL.castShadow = true;
        torso.add(legL);
        
        const legR = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.9, 0.3), blueMat);
        legR.position.set(0.2, -0.9, 0);
        legR.castShadow = true;
        torso.add(legR);

        group.userData = { armR, armL, legL, legR };
        return group;
    }

    function createCivilian() {
        const group = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({color: 0xFFFFFF, roughness: 0.7});
        
        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.9, 0.4), mat);
        torso.position.y = 1.3;
        torso.castShadow = true;
        group.add(torso);
        
        const head = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.6, 0.6),
            new THREE.MeshStandardMaterial({color: 0xFFCCAA, roughness: 0.6})
        );
        head.position.y = 0.85;
        head.castShadow = true;
        torso.add(head);
        
        const leg = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.9, 0.3),
            new THREE.MeshStandardMaterial({color: 0x444444, roughness: 0.8})
        );
        leg.position.y = 0.45;
        leg.castShadow = true;
        group.add(leg);
        
        const arm = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.8, 0.2),
            new THREE.MeshStandardMaterial({color: 0xFFCCAA, roughness: 0.6})
        );
        arm.position.set(0.5, 0.4, 0.3);
        arm.rotation.x = -0.5;
        arm.castShadow = true;
        torso.add(arm);
        
        const phone = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.25, 0.05),
            new THREE.MeshStandardMaterial({
                color: 0x00AAFF,
                emissive: 0x0088DD,
                emissiveIntensity: 1
            })
        );
        phone.position.set(0, -0.4, 0);
        arm.add(phone);
        
        const alertIcon = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 8, 8),
            new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 2,
                transparent: true,
                opacity: 0
            })
        );
        alertIcon.position.y = 1.5;
        group.add(alertIcon);
        group.userData.alertIcon = alertIcon;
        
        return group;
    }

    // === VEH√çCULOS ===
    function createTaxiMesh() {
        const group = new THREE.Group();
        
        const taxiMat = new THREE.MeshStandardMaterial({
            color: COLORS.taxi,
            roughness: 0.3,
            metalness: 0.6
        });
        
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.0, 4.0), taxiMat);
        body.position.y = 0.7;
        body.castShadow = true;
        group.add(body);
        
        const hood = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.3, 1.0), taxiMat);
        hood.position.set(0, 0.5, 2.2);
        hood.castShadow = true;
        group.add(hood);
        
        const cabin = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 0.7, 2.2),
            taxiMat
        );
        cabin.position.set(0, 1.3, -0.3);
        cabin.castShadow = true;
        group.add(cabin);
        
        const windowMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.1,
            metalness: 0.9,
            transparent: true,
            opacity: 0.6
        });
        
        const windshield = new THREE.Mesh(
            new THREE.BoxGeometry(1.4, 0.6, 0.1),
            windowMat
        );
        windshield.position.set(0, 1.25, 0.8);
        windshield.rotation.x = 0.2;
        group.add(windshield);
        
        const sideWindowL = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.5, 2.0),
            windowMat
        );
        sideWindowL.position.set(0.75, 1.25, -0.3);
        group.add(sideWindowL);
        
        const sideWindowR = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.5, 2.0),
            windowMat
        );
        sideWindowR.position.set(-0.75, 1.25, -0.3);
        group.add(sideWindowR);
        
        const sign = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.25, 0.4),
            new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                emissive: 0xFF0000,
                emissiveIntensity: 0.5
            })
        );
        sign.position.set(0, 1.8, -0.3);
        sign.castShadow = true;
        group.add(sign);
        
        const bumperMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.4,
            metalness: 0.6
        });
        
        const frontBumper = new THREE.Mesh(
            new THREE.BoxGeometry(1.7, 0.2, 0.3),
            bumperMat
        );
        frontBumper.position.set(0, 0.3, 2.8);
        frontBumper.castShadow = true;
        group.add(frontBumper);
        
        const rearBumper = new THREE.Mesh(
            new THREE.BoxGeometry(1.7, 0.2, 0.3),
            bumperMat
        );
        rearBumper.position.set(0, 0.3, -2.8);
        rearBumper.castShadow = true;
        group.add(rearBumper);
        
        const headlightMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFAA,
            emissive: 0xFFFFAA,
            emissiveIntensity: 1.5
        });
        
        const headlightL = new THREE.Mesh(
            new THREE.BoxGeometry(0.25, 0.25, 0.1),
            headlightMat
        );
        headlightL.position.set(0.5, 0.5, 2.85);
        group.add(headlightL);
        
        const headlightR = new THREE.Mesh(
            new THREE.BoxGeometry(0.25, 0.25, 0.1),
            headlightMat
        );
        headlightR.position.set(-0.5, 0.5, 2.85);
        group.add(headlightR);
        
        const wheelMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.9
        });
        
        const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.25, 12);
        
        const positions = [
            [0.7, 0.35, 1.5],
            [-0.7, 0.35, 1.5],
            [0.7, 0.35, -1.5],
            [-0.7, 0.35, -1.5]
        ];
        
        positions.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeo, wheelMat);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(...pos);
            wheel.castShadow = true;
            group.add(wheel);
            
            const rim = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 0.26, 12),
                new THREE.MeshStandardMaterial({color: 0x888888, metalness: 0.8, roughness: 0.2})
            );
            rim.rotation.z = Math.PI / 2;
            rim.position.set(...pos);
            group.add(rim);
        });
        
        const mirrorMat = new THREE.MeshStandardMaterial({
            color: 0x333333,
            metalness: 0.7,
            roughness: 0.3
        });
        
        const mirrorL = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.15, 0.2),
            mirrorMat
        );
        mirrorL.position.set(0.85, 1.2, 0.5);
        group.add(mirrorL);
        
        const mirrorR = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.15, 0.2),
            mirrorMat
        );
        mirrorR.position.set(-0.85, 1.2, 0.5);
        group.add(mirrorR);
        
        return group;
    }

    function createBusMesh() {
        const group = new THREE.Group();
        
        const busMat = new THREE.MeshStandardMaterial({
            color: COLORS.bus,
            roughness: 0.4,
            metalness: 0.5
        });
        
        const body1 = new THREE.Mesh(new THREE.BoxGeometry(2.0, 2.8, 5.0), busMat);
        body1.position.set(0, 1.6, 0);
        body1.castShadow = true;
        group.add(body1);
        
        const body2 = new THREE.Mesh(new THREE.BoxGeometry(2.0, 2.8, 4.0), busMat);
        body2.position.set(0, 1.6, -5.5);
        body2.castShadow = true;
        group.add(body2);
        
        const accordion = new THREE.Mesh(
            new THREE.BoxGeometry(1.8, 2.6, 1.0),
            new THREE.MeshStandardMaterial({color: 0x0A2540, roughness: 0.8})
        );
        accordion.position.set(0, 1.6, -3.0);
        group.add(accordion);
        
        const stripe = new THREE.Mesh(
            new THREE.BoxGeometry(2.05, 0.4, 9.5),
            new THREE.MeshStandardMaterial({color: 0xFFFFFF})
        );
        stripe.position.y = 1.2;
        group.add(stripe);
        
        const windowMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.1,
            metalness: 0.9,
            transparent: true,
            opacity: 0.5
        });
        
        for(let z = -6; z < 3; z += 1.5) {
            const winL = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 1.0, 1.0),
                windowMat
            );
            winL.position.set(1.05, 2.2, z);
            group.add(winL);
            
            const winR = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 1.0, 1.0),
                windowMat
            );
            winR.position.set(-1.05, 2.2, z);
            group.add(winR);
        }
        
        const windshield = new THREE.Mesh(
            new THREE.BoxGeometry(1.8, 1.2, 0.1),
            windowMat
        );
        windshield.position.set(0, 2.0, 2.6);
        windshield.rotation.x = 0.15;
        group.add(windshield);
        
        const headlightMat = new THREE.MeshStandardMaterial({
            color: 0xFFFFAA,
            emissive: 0xFFFFAA,
            emissiveIntensity: 1.8
        });
        
        const hlL = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.1),
            headlightMat
        );
        hlL.position.set(0.7, 0.8, 2.55);
        group.add(hlL);
        
        const hlR = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.1),
            headlightMat
        );
        hlR.position.set(-0.7, 0.8, 2.55);
        group.add(hlR);
        
        const tailLightMat = new THREE.MeshStandardMaterial({
            color: 0xFF0000,
            emissive: 0xFF0000,
            emissiveIntensity: 1.5
        });
        
        const tlL = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.1),
            tailLightMat
        );
        tlL.position.set(0.7, 0.8, -7.55);
        group.add(tlL);
        
        const tlR = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.1),
            tailLightMat
        );
        tlR.position.set(-0.7, 0.8, -7.55);
        group.add(tlR);
        
        const wheelMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.9
        });
        
        const wheelGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.3, 16);
        
        const wheelPos = [
            [0.85, 0.45, 1.5],
            [-0.85, 0.45, 1.5],
            [0.85, 0.45, -1.5],
            [-0.85, 0.45, -1.5],
            [0.85, 0.45, -5.0],
            [-0.85, 0.45, -5.0]
        ];
        
        wheelPos.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeo, wheelMat);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(...pos);
            wheel.castShadow = true;
            group.add(wheel);
        });
        
        return group;
    }

    // === SISTEMA DE PART√çCULAS ===
    function createParticle(type, position) {
        const group = new THREE.Group();
        
        if (type === 'dust') {
            for(let i = 0; i < 3; i++) {
                const particle = new THREE.Mesh(
                    new THREE.BoxGeometry(0.1, 0.1, 0.1),
                    new THREE.MeshStandardMaterial({
                        color: 0xAAAAAA,
                        transparent: true,
                        opacity: 0.6
                    })
                );
                particle.position.set(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.2,
                    (Math.random() - 0.5) * 0.5
                );
                group.add(particle);
            }
        } else if (type === 'coin') {
            for(let i = 0; i < 8; i++) {
                const spark = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.08, 0.08),
                    new THREE.MeshStandardMaterial({
                        color: 0xFFD700,
                        emissive: 0xFFAA00,
                        emissiveIntensity: 2
                    })
                );
                const angle = (i / 8) * Math.PI * 2;
                spark.userData.velocity = new THREE.Vector3(
                    Math.cos(angle) * 0.5,
                    1 + Math.random() * 0.5,
                    Math.sin(angle) * 0.5
                );
                group.add(spark);
            }
        } else if (type === 'crash') {
            for(let i = 0; i < 12; i++) {
                const piece = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.15, 0.15),
                    new THREE.MeshStandardMaterial({
                        color: [0xFF0000, 0xFFAA00, 0x333333][Math.floor(Math.random() * 3)]
                    })
                );
                piece.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 2,
                    (Math.random() - 0.5) * 2
                );
                piece.userData.rotVel = new THREE.Vector3(
                    Math.random() * 0.2,
                    Math.random() * 0.2,
                    Math.random() * 0.2
                );
                group.add(piece);
            }
        }
        
        group.position.copy(position);
        group.userData.life = 1.0;
        group.userData.type = type;
        scene.add(group);
        particles.push(group);
    }

    function updateParticles(dt) {
        for(let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.userData.life -= dt;
            
            if(p.userData.life <= 0) {
                scene.remove(p);
                particles.splice(i, 1);
                continue;
            }
            
            p.children.forEach(child => {
                if(child.userData.velocity) {
                    child.position.add(child.userData.velocity.clone().multiplyScalar(dt));
                    child.userData.velocity.y -= 9.8 * dt;
                }
                if(child.userData.rotVel) {
                    child.rotation.x += child.userData.rotVel.x;
                    child.rotation.y += child.userData.rotVel.y;
                    child.rotation.z += child.userData.rotVel.z;
                }
                if(child.material.opacity !== undefined) {
                    child.material.opacity = p.userData.life;
                }
            });
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        
        if(cameraShake > 0) {
            cameraShake -= dt * 5;
            camera.position.x += (Math.random() - 0.5) * cameraShakeIntensity;
            camera.position.y += (Math.random() - 0.5) * cameraShakeIntensity;
        }
        
        updateParticles(dt);
        
        if (gameState === 'PLAYING') updateGame(dt, clock.elapsedTime);
        else if (gameState === 'INTRO') updateIntro(dt);
        else if (gameState === 'ARREST') updateArrest(dt, clock.elapsedTime);

        if(renderer && scene && camera) renderer.render(scene, camera);
    }

    // --- INTRO ---
    function triggerIntroSequence() {
        gameState = 'INTRO';
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('game-over').classList.add('hidden');
        introTimer = 0;
        hasWhistlePlayed = false;

        obstacles.forEach(o=>scene.remove(o.mesh));
        obstacles=[];
        scenery.forEach(o=>scene.remove(o));
        scenery=[];
        cops.forEach(c=>scene.remove(c));
        cops=[];
        particles.forEach(p=>scene.remove(p));
        particles=[];
        if(civilianGroup) scene.remove(civilianGroup);

        createPlayer();
        playerGroup.position.set(0, 0, -2);
        playerGroup.rotation.y = Math.PI;

        civilianGroup = createCivilian();
        civilianGroup.position.set(0, 0, 1);
        civilianGroup.rotation.y = Math.PI;
        scene.add(civilianGroup);

        const c1 = createCop(1);
        c1.position.set(3, 0, -10);
        scene.add(c1);
        cops.push(c1);
        
        const c2 = createCop(-1);
        c2.position.set(-3, 0, -10);
        scene.add(c2);
        cops.push(c2);

        camera.position.set(2, 0.5, 4);
        camera.lookAt(0, 1, 0);
    }

    function updateIntro(dt) {
        introTimer += dt;
        
        camera.position.y = THREE.MathUtils.lerp(camera.position.y, 2 + introTimer * 0.5, dt * 2);
        
        if (introTimer < 1.0) {
            playerGroup.position.z = THREE.MathUtils.lerp(playerGroup.position.z, 0.5, dt*2);
            if(playerLimbs.armR) playerLimbs.armR.rotation.x = -0.8;
        }
        else if (introTimer < 2.0) {
            if(introTimer < 1.2) {
                playerGroup.position.z = 0.8;
                if(playerLimbs.armR) playerLimbs.armR.rotation.x = -1.5;
            }
            
            const bounce = Math.abs(Math.sin(introTimer*20));
            civilianGroup.position.y = bounce * 0.4;
            civilianGroup.scale.y = 1 - bounce * 0.3;
            civilianGroup.scale.x = 1 + bounce * 0.2;
            
            if(civilianGroup.userData.alertIcon) {
                civilianGroup.userData.alertIcon.material.opacity = Math.min(1, (introTimer - 1) * 3);
                civilianGroup.userData.alertIcon.scale.set(1 + bounce, 1 + bounce, 1 + bounce);
            }
            
            if(!hasWhistlePlayed) {
                playSound('powerup');
                document.getElementById('intro-text').classList.add('pop-in');
                hasWhistlePlayed = true;
            }
            cops.forEach(c => c.position.z += dt*8);
        }
        else if (introTimer < 3.0) {
            playerGroup.rotation.y = THREE.MathUtils.lerp(playerGroup.rotation.y, 0, dt*10);
            camera.position.lerp(new THREE.Vector3(0, 5, 10), dt*3);
            camera.lookAt(0, 0, -5);
            document.getElementById('intro-text').classList.remove('pop-in');
        }
        else {
            scene.remove(civilianGroup);
            cops.forEach(c => scene.remove(c));
            cops=[];
            startGame();
        }
    }

    // --- GAMEPLAY ---
    function updateGame(dt, time) {
        speed += dt * 0.25;
        score += speed * dt;
        document.getElementById('score-lbl').innerText = Math.floor(score)+"m";

        const targetX = lanes[currentLane];
        playerGroup.position.x += (targetX - playerGroup.position.x) * 18 * dt;
        playerGroup.rotation.z = (playerGroup.position.x - targetX) * -0.1;

        verticalVel += GRAVITY * dt;
        playerY += verticalVel * dt;
        if(playerY <= 0) {
            playerY = 0;
            verticalVel = 0;
            isJumping = false;
            if(verticalVel < -5) {
                createParticle('dust', playerGroup.position.clone());
            }
        }
        playerGroup.position.y = playerY;

        if(isDucking) {
            playerGroup.scale.y = 0.5;
            duckTimer -= dt;
            if(duckTimer <= 0) {
                isDucking = false;
                playerGroup.scale.y = 1;
            }
        }

        const runSpeed = speed * 0.8;
        const angle = Math.sin(time * runSpeed) * 1.0;
        if(playerLimbs.legL) {
            playerLimbs.legL.rotation.x = angle;
            playerLimbs.legR.rotation.x = -angle;
            playerLimbs.armL.rotation.x = -angle * 0.8;
            playerLimbs.armR.rotation.x = angle * 0.8;
        }
        
        if(Math.random() > 0.85 && !isJumping) {
            createParticle('dust', new THREE.Vector3(
                playerGroup.position.x,
                0.1,
                playerGroup.position.z - 0.5
            ));
        }

        // FIX 1: Mover l√≠neas amarillas
        updateRoadLines(dt);

        sceneryTimer += dt;
        if (sceneryTimer > 0.08) {
            sceneryTimer = 0;
            spawnBahiaDecor();
        }
        
        masterSpawnTimer += dt;
        if (masterSpawnTimer > 35/speed) {
            masterSpawnTimer = 0;
            spawnEntityWave();
        }

        updateEntities(dt);
    }

    // FIX 1: Mover y reciclar l√≠neas amarillas
    function updateRoadLines(dt) {
        const moveAmount = speed * dt;
        for(let i = 0; i < roadLines.length; i++) {
            roadLines[i].position.z += moveAmount;
            // Si la l√≠nea pasa de la c√°mara, la mando al fondo
            if(roadLines[i].position.z > 12) {
                roadLines[i].position.z -= 200; // 20 l√≠neas * 10 de espaciado = 200
            }
        }
    }

    // --- SPAWNERS ---
    function spawnEntityWave() {
        const r = Math.random();
        if (r < 0.4) {
            const safe = Math.floor(Math.random()*3);
            for(let i=0; i<3; i++) {
                if(i !== safe) spawnObstacle(i);
                else if(Math.random() > 0.5) spawnCoinRow(i);
            }
        } else if (r < 0.8) {
            spawnObstacle(Math.floor(Math.random()*3));
        } else {
            const l = Math.floor(Math.random()*3);
            const rr = Math.random();
            if(rr<0.1) spawnSpecialItem(l, 'iphone');
            else if(rr<0.3) spawnSpecialItem(l, 'phone');
            else spawnCoinRow(l);
        }
    }

    function spawnObstacle(laneIdx) {
        const x = lanes[laneIdx];
        const r = Math.random();
        let type = '', mesh;

        if (r < 0.3) {
            type = 'low';
            mesh = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.8, 0.2),
                new THREE.MeshStandardMaterial({
                    color: 0xFF4444,
                    roughness: 0.6,
                    emissive: 0xFF2222,
                    emissiveIntensity: 0.2
                })
            );
            mesh.position.set(x, 0.4, -120);
            mesh.castShadow = true;
        } else if (r < 0.6) {
            type = 'high';
            mesh = new THREE.Group();
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 0.8, 0.1),
                new THREE.MeshStandardMaterial({color: 0xCCCCCC, roughness: 0.5})
            );
            sign.position.y = 2.2;
            sign.castShadow = true;
            
            const p1 = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 2.5, 0.1),
                new THREE.MeshStandardMaterial({color: 0x555555, metalness: 0.5, roughness: 0.6})
            );
            p1.position.set(-1, 1, 0);
            p1.castShadow = true;
            
            const p2 = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 2.5, 0.1),
                new THREE.MeshStandardMaterial({color: 0x555555, metalness: 0.5, roughness: 0.6})
            );
            p2.position.set(1, 1, 0);
            p2.castShadow = true;
            
            mesh.add(sign);
            mesh.add(p1);
            mesh.add(p2);
            mesh.position.set(x, 0, -120);
        } else if (r < 0.8) {
            type = 'full';
            mesh = createTaxiMesh();
            mesh.position.set(x, 0, -120);
        } else {
            type = 'full';
            mesh = createBusMesh();
            mesh.position.set(x, 0, -120);
        }
        scene.add(mesh);
        obstacles.push({mesh, type, lane:laneIdx});
    }

    // --- ARREST ---
    function triggerArrest() {
        gameState = 'ARREST';
        arrestTimer = 0;
        hasHitPlayed = false;
        
        cameraShake = 0.5;
        cameraShakeIntensity = 0.2;
        
        createParticle('crash', playerGroup.position.clone());
        
        playSound('crash');
        playerGroup.rotation.set(0, 0, 0);
        playerGroup.position.y = 0;
        playerGroup.scale.y = 1;
        
        const pPos = playerGroup.position.clone();
        
        const c1 = createCop(1);
        c1.position.set(pPos.x+1.1, 0, pPos.z);
        c1.rotation.y = -0.3;
        scene.add(c1);
        cops.push(c1);
        
        const c2 = createCop(-1);
        c2.position.set(pPos.x-1.1, 0, pPos.z);
        c2.rotation.y = 0.3;
        scene.add(c2);
        cops.push(c2);
    }

    function updateArrest(dt, time) {
        arrestTimer += dt;
        
        if (arrestTimer < 0.4) {
            cops.forEach(c => {
                c.userData.armR.rotation.x = THREE.MathUtils.lerp(
                    c.userData.armR.rotation.x,
                    -Math.PI/1.5,
                    dt*5
                );
            });
            camera.position.lerp(
                new THREE.Vector3(playerGroup.position.x, 2.5, playerGroup.position.z + 5),
                dt*3
            );
        }
        else if (arrestTimer < 0.8) {
            cops.forEach(c => {
                c.userData.armR.rotation.x = THREE.MathUtils.lerp(
                    c.userData.armR.rotation.x,
                    0.5,
                    dt*15
                );
            });
            playerGroup.rotation.x = THREE.MathUtils.lerp(playerGroup.rotation.x, 0.6, dt*10);
            
            if(!hasHitPlayed && arrestTimer > 0.5) {
                playSound('crash');
                cameraShake = 1.0;
                cameraShakeIntensity = 0.3;
                createParticle('crash', playerGroup.position.clone());
                hasHitPlayed = true;
            }
        }
        else if (arrestTimer < 3.5) {
            const w = 2 * dt;
            playerGroup.position.z -= w;
            playerGroup.position.x += w*0.2;
            cops.forEach(c => {
                c.position.z -= w;
                c.position.x += w*0.2;
            });
            
            const marchSpeed = 10;
            const ang = Math.sin(time * marchSpeed) * 0.7;
            
            cops.forEach(c => {
                if(c.userData.legL) {
                    c.userData.legL.rotation.x = ang;
                    c.userData.legR.rotation.x = -ang;
                    c.userData.armL.rotation.x = -ang * 0.5;
                }
            });
            
            if(playerLimbs.legL) {
                playerLimbs.legL.rotation.x = ang;
                playerLimbs.legR.rotation.x = -ang;
            }
            
            playerGroup.rotation.x = THREE.MathUtils.lerp(playerGroup.rotation.x, 0.2, dt*2);
        } else {
            showGameOverScreen();
        }
        
        camera.lookAt(playerGroup.position.x, 1.5, playerGroup.position.z);
    }

    // --- HELPERS ---
    function spawnCoinRow(idx) {
        for(let i=0; i<5; i++) {
            const c = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 0.1, 12),
                new THREE.MeshStandardMaterial({
                    color: 0xFFD700,
                    emissive: 0xFFAA00,
                    emissiveIntensity: 1,
                    roughness: 0.3,
                    metalness: 0.8
                })
            );
            c.rotation.x = Math.PI/2;
            c.position.set(lanes[idx], 1, -120-(i*3));
            c.castShadow = true;
            scene.add(c);
            obstacles.push({mesh:c, type:'coin', lane:idx, active:true});
        }
    }

    function spawnSpecialItem(idx, type) {
        const x = lanes[idx];
        const g = new THREE.Group();
        const col = type==='iphone' ? 0xFFFFFF : 0x222222;
        
        const b = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.8, 0.1),
            new THREE.MeshStandardMaterial({
                color: col,
                roughness: 0.2,
                metalness: 0.8
            })
        );
        b.castShadow = true;
        
        const s = new THREE.Mesh(
            new THREE.PlaneGeometry(0.4, 0.7),
            new THREE.MeshStandardMaterial({
                color: 0x00AAFF,
                emissive: 0x0088DD,
                emissiveIntensity: 2
            })
        );
        s.position.z = 0.06;
        
        g.add(b);
        g.add(s);
        g.position.set(x, 1, -120);
        scene.add(g);
        obstacles.push({mesh:g, type:type, lane:idx, active:true});
    }
    
    // FIX 2: spawnBahiaDecor ahora tambi√©n spawn edificios laterales
    function spawnBahiaDecor() {
        const side = Math.random()>0.5 ? 1:-1;
        const xBase = side*(7+Math.random()*3);
        
        if(Math.random()<0.6) {
            const col = Math.random()>0.5 ? 0x0033A0 : 0xFF8800;
            const t = new THREE.Mesh(
                new THREE.BoxGeometry(4, 0.1, 4),
                new THREE.MeshStandardMaterial({color:col, roughness: 0.7})
            );
            t.position.set(xBase, 3.5, -120);
            t.castShadow = true;
            t.receiveShadow = true;
            
            const p = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 3.5, 0.1),
                new THREE.MeshStandardMaterial({color:0x555555, metalness: 0.5, roughness: 0.6})
            );
            p.position.set(-1.5, -1.75, 1.5);
            p.castShadow = true;
            t.add(p);
            
            scene.add(t);
            scenery.push(t);
        } else {
            const b = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 1.5, 1.5),
                new THREE.MeshStandardMaterial({color:0x8B4513, roughness: 0.9})
            );
            b.position.set(xBase, 0.75, -120);
            b.castShadow = true;
            scene.add(b);
            scenery.push(b);
        }

        // FIX 2: Spawn edificios laterales cada vez que se hace decor
        // Se alternan lados y frecuencia para que no sea demasiado denso
        if(Math.random() < 0.35) {
            const bSide = Math.random() > 0.5 ? 1 : -1;
            const { group } = createSideBuilding();
            // Posicionar fuera de la vereda (vereda est√° en ¬±8.5, ancho 5 -> borde en ¬±11)
            // El edificio se mete entre 12 y 17 de distancia al centro
            const buildingX = bSide * (13 + Math.random() * 4);
            group.position.set(buildingX, 0, -120);
            scene.add(group);
            scenery.push(group);
        }
    }

    function updateEntities(dt) {
        for(let i=obstacles.length-1; i>=0; i--) {
            let ob = obstacles[i];
            ob.mesh.position.z += speed*dt;
            
            if(['coin','phone','iphone'].includes(ob.type)) {
                ob.mesh.rotation.y += dt*4;
            }
            
            if(ob.mesh.position.z > -1 && ob.mesh.position.z < 1) {
                if(currentLane === ob.lane) {
                    if(['coin','phone','iphone'].includes(ob.type)) {
                        if(ob.active) {
                            let val = ob.type==='coin' ? 1 : (ob.type==='iphone' ? 100 : 50);
                            collectMoney(val);
                            if(val>1) showPopup("+$"+val);
                            
                            playSound(val>1 ? 'powerup' : 'coin');
                            
                            createParticle('coin', ob.mesh.position.clone());
                            
                            scene.remove(ob.mesh);
                            ob.active = false;
                            obstacles.splice(i, 1);
                        }
                        continue;
                    }
                    
                    let hit = false;
                    if(ob.type==='low' && playerGroup.position.y < 0.5) hit=true;
                    if(ob.type==='high' && !isDucking) hit=true;
                    if(ob.type==='full') hit=true;
                    if(hit) triggerArrest();
                }
            }
            if(ob.mesh.position.z > 10) {
                scene.remove(ob.mesh);
                obstacles.splice(i, 1);
            }
        }
        
        for(let i=scenery.length-1; i>=0; i--) {
            scenery[i].position.z += speed*dt;
            if(scenery[i].position.z>15) {
                scene.remove(scenery[i]);
                scenery.splice(i, 1);
            }
        }
    }

    function collectMoney(v) {
        cash += v;
        document.getElementById('cash-lbl').innerText = "$"+cash;
    }
    
    function showPopup(t) {
        const el = document.getElementById('popup-msg');
        el.innerText = t;
        el.style.opacity = 1;
        setTimeout(() => el.style.opacity = 0, 800);
    }
    
    function playSound(t) {
        if(!audioCtx) audioCtx = new(window.AudioContext||window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.connect(g);
        g.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        if(t==='coin') {
            o.frequency.setValueAtTime(1200, now);
            o.frequency.exponentialRampToValueAtTime(2000, now+0.1);
            g.gain.setValueAtTime(0.1, now);
            g.gain.exponentialRampToValueAtTime(0.01, now+0.1);
            o.start(now);
            o.stop(now+0.1);
        } else if(t==='powerup') {
            o.frequency.setValueAtTime(400, now);
            o.frequency.linearRampToValueAtTime(800, now+0.2);
            g.gain.setValueAtTime(0.1, now);
            g.gain.linearRampToValueAtTime(0, now+0.2);
            o.start(now);
            o.stop(now+0.2);
        } else if(t==='crash') {
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(100, now);
            g.gain.setValueAtTime(0.3, now);
            g.gain.exponentialRampToValueAtTime(0.01, now+0.3);
            o.start(now);
            o.stop(now+0.3);
        }
    }

    function renderShop() {
        const g = document.getElementById('shop-grid');
        g.innerHTML = '';
        document.getElementById('shop-cash').innerText = "$"+totalCash;
        
        SKINS.forEach(s => {
            const own = ownedSkins.includes(s.id);
            const eq = currentSkinId === s.id;
            const d = document.createElement('div');
            d.className = `shop-item ${own?'owned':''} ${eq?'equipped':''}`;
            d.innerHTML = `<div class="preview-box">${s.icon}</div><strong>${s.name}</strong><small style="color:#aaa">${s.desc}</small><div style="margin-top:5px; color:${own?'#4CAF50':'#FFC107'}">${eq?'EQUIPADO':(own?'EN PROPIEDAD':'$'+s.price)}</div>`;
            d.onclick = () => {
                if(own) {
                    currentSkinId = s.id;
                    saveData();
                    renderShop();
                    playSound('coin');
                } else if(totalCash >= s.price) {
                    totalCash -= s.price;
                    ownedSkins.push(s.id);
                    currentSkinId = s.id;
                    saveData();
                    renderShop();
                    playSound('powerup');
                } else {
                    alert("¬°Tas chiro!");
                }
            };
            g.appendChild(d);
        });
    }
    
    function saveData() {
        localStorage.setItem('gh_total_cash', totalCash);
        localStorage.setItem('gh_owned_skins', JSON.stringify(ownedSkins));
        localStorage.setItem('gh_current_skin', currentSkinId);
        localStorage.setItem('gh_best_score', bestScore);
    }

    function setupInputs() {
        document.addEventListener('keydown', e => {
            if(gameState !== 'PLAYING') return;
            if(e.key === 'ArrowLeft') currentLane = Math.max(0, currentLane-1);
            if(e.key === 'ArrowRight') currentLane = Math.min(2, currentLane+1);
            if(e.key === 'ArrowUp' && !isJumping) {
                isJumping = true;
                verticalVel = JUMP_FORCE;
                isDucking = false;
            }
            if(e.key === 'ArrowDown' && !isJumping) {
                isDucking = true;
                duckTimer = 0.8;
            }
        });
        
        let sx=0, sy=0;
        document.addEventListener('touchstart', e => {
            sx = e.touches[0].clientX;
            sy = e.touches[0].clientY;
        }, {passive:false});
        
        document.addEventListener('touchend', e => {
            if(gameState !== 'PLAYING') return;
            let dx = e.changedTouches[0].clientX - sx;
            let dy = e.changedTouches[0].clientY - sy;
            
            if(Math.abs(dx) > Math.abs(dy)) {
                if(dx > 30) currentLane = Math.min(2, currentLane+1);
                else if(dx < -30) currentLane = Math.max(0, currentLane-1);
            } else {
                if(dy < -30 && !isJumping) {
                    isJumping = true;
                    verticalVel = JUMP_FORCE;
                    isDucking = false;
                } else if(dy > 30) {
                    isDucking = true;
                    duckTimer = 0.8;
                }
            }
        }, {passive:false});
    }

    function startGame() {
        gameState = 'PLAYING';
        document.getElementById('hud').classList.remove('hidden');
        score = 0;
        cash = 0;
        speed = 10;
        currentLane = 1;
        
        createPlayer();
        
        obstacles.forEach(o => scene.remove(o.mesh));
        obstacles = [];
        scenery.forEach(o => scene.remove(o));
        scenery = [];
        particles.forEach(p => scene.remove(p));
        particles = [];
        
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, -5);
    }
    
    // FIX 3: Actualizar record y mostrar en game over + men√∫
    function showGameOverScreen() {
        gameState = 'GAMEOVER';
        totalCash += cash;

        // Actualizar record si es nuevo
        const finalDist = Math.floor(score);
        if(finalDist > bestScore) {
            bestScore = finalDist;
        }

        saveData();
        
        document.getElementById('hud').classList.add('hidden');
        document.getElementById('game-over').classList.remove('hidden');
        document.getElementById('final-score').innerText = finalDist+"m";
        document.getElementById('final-cash').innerText = "$"+cash;
    }
    
    function goToMenu() {
        document.getElementById('game-over').classList.add('hidden');
        document.getElementById('main-menu').classList.remove('hidden');
        updateMenuStats(); // FIX 3: Refrescar stats al volver al men√∫
        gameState = 'MENU';
    }
    
    function openShop() {
        renderShop();
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('shop-screen').classList.remove('hidden');
    }
    
    function closeShop() {
        document.getElementById('shop-screen').classList.add('hidden');
        document.getElementById('main-menu').classList.remove('hidden');
        updateMenuStats(); // FIX 3: Refrescar stats al volver del shop (por si compraste algo)
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>